{"code":"import * as tslib_1 from \"tslib\";\r\n// wrap method with decorator function\r\nexport default (errorClass, handler) => {\r\n    return (target, propertyKey, descriptor) => {\r\n        // save a reference to the original method\r\n        const originalMethod = descriptor.value;\r\n        // rewrite original method with custom wrapper\r\n        descriptor.value = function (...args) {\r\n            return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    return yield originalMethod.apply(this, args);\r\n                }\r\n                catch (error) {\r\n                    // check if error is instance of passed error class\r\n                    if (error && handler && error instanceof errorClass) {\r\n                        // run handler with error object \r\n                        // and class context as second argument\r\n                        return handler.call(this, error, this);\r\n                    }\r\n                    // throw error \r\n                    throw error;\r\n                }\r\n            });\r\n        };\r\n        return descriptor;\r\n    };\r\n};\r\n","dts":{"name":"/Users/tarasbatenkov/Projects/catch-decorator/index.d.ts","text":"declare const _default: (errorClass: any, handler: (error: any) => any) => any;\r\nexport default _default;\r\n"}}
