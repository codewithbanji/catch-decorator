{"code":"function handleError(ctx, errorClass, handler, error) {\r\n    // check if error is instance of passed error class\r\n    if (typeof handler === 'function' && error instanceof errorClass) {\r\n        // run handler with error object \r\n        // and class context as second argument\r\n        handler.call(null, error, ctx);\r\n    }\r\n    else {\r\n        // throw error further,\r\n        // next decorator in chain can catch it\r\n        throw error;\r\n    }\r\n}\r\n// decorator factory function\r\nexport default (errorClass, handler) => {\r\n    return (target, propertyKey, descriptor) => {\r\n        // save a reference to the original method\r\n        const originalMethod = descriptor.value;\r\n        // rewrite original method with custom wrapper\r\n        descriptor.value = function (...args) {\r\n            try {\r\n                const result = originalMethod.apply(this, args);\r\n                // check if method is asynchronous\r\n                if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\r\n                    // return promise\r\n                    return result.catch((error) => {\r\n                        handleError(this, errorClass, handler, error);\r\n                    });\r\n                }\r\n                // return actual result\r\n                return result;\r\n            }\r\n            catch (error) {\r\n                handleError(this, errorClass, handler, error);\r\n            }\r\n        };\r\n        return descriptor;\r\n    };\r\n};\r\n","dts":{"name":"/Users/tarasbatenkov/Projects/catch-decorator/index.d.ts","text":"declare const _default: (errorClass: any, handler: (error: any, ctx: any) => void) => any;\r\nexport default _default;\r\n"}}
